<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Learn Byteball(1) | Ian He&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/avator.png">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
</head>

<body>
  <nav class="app-nav">
  
    
        <a href="/."><button>home</button></a>
      
    
    
        <a href="/archives"><button>archive</button></a>
      
    
    
        <a href="/tags"><button>tags</button></a>
      
    
    
        <a href="/about"><button>about</button></a>
      
    
</nav>
<script src="/js/button.js"></script>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2018/05/01/Learn-Byteball-1/">Learn Byteball(1)</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">五月 01 2018</p>
  </section>
  
  <section class="article-entry">
    <h1 id="Learn-Byteball-1"><a href="#Learn-Byteball-1" class="headerlink" title="Learn Byteball(1)"></a>Learn Byteball(1)</h1><p>虽然接触区块链和数字货币也已一年有余，然而真正开始认真研究区块链底层代码逻辑却时日不多。在这有限的时间内，却看到了很多学习到了很多，于是想总结下来，也是为了日后参考。</p>
<p>因为公司的链是基于DAG和Byteball的，所以在正式开始开发链的工作之前，学习byteball的代码逻辑是首要工作，也是这一系列主要想表现的内容。</p>
<h2 id="Light-Client"><a href="#Light-Client" class="headerlink" title="Light Client"></a>Light Client</h2><p>Byteball的目前有两种比较常有的钱包，一种称为全钱包，这种钱包存储了Byteball的所有数据信息；一种称为轻钱包，这种钱包只包含和使用者相关的信息。所以很容易发现，轻钱包占用存储空间更小，非常适合移动端使用。不过轻钱包的问题在于依赖Hub（轻钱包服务供应商），一旦Hub出现问题（被攻击或者故障了）就无法提供服务。</p>
<h3 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h3><p>Light Client默认存储了12个公证人信息，以及用户输入的助记词以及生产的私钥、公钥和地址。在启动之后以及定时，会向Hub发送公证人列表和地址以获取历史交易记录。</p>
<h3 id="ProofChain"><a href="#ProofChain" class="headerlink" title="ProofChain"></a>ProofChain</h3><p>这是Byteball比较独特的一个功能。这个功能的目的，是将所有的单元串联起来，来证明之前的交易是存在于链上的。</p>
<p>轻节点会连接到全节点下载信息：向全节点发送自己的公证人列表和地址列表。全节点则通过这新信息去查询每一个节点，并为每一个节点通过以下方法建立一个ProofChain。</p>
<ul>
<li>沿着MC回溯，直到遇到多数公证人，收集所有的MC单元。</li>
<li>从这个集合的最后一个单元（也就是时间上最早的），读取最终球。</li>
<li>从这个最终球开始，沿着MC回溯，直到遇到有跳表的球，收集所有的球。</li>
<li>使用跳表，跳到该跳表引用的最早的球，该球也有跳表，接着跳。跳表数组中一般都有几个球，尽可能选择距离最远的那个球跳，于是我们不断加速跳跃，一开始10个MCI，然后100个，然后1000个等等。</li>
<li>如果跳表的下一次跳跃将会跳到目标球的后面，那就选择较小的跳跃距离减速。最后，抛弃跳表，沿着MC只利用父单元链接一步一步的回溯。</li>
</ul>
<p>链上的所有单元通过父单元（收集公证人时）或者最终球引用或者父球或者跳表关联。在链条的末端，是我们要证明其存在的单元。</p>

  </section>
</article>

</main>

</body>
</html>
